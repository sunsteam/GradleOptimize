//https://github.com/Tencent/tinker/wiki/Tinker-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98#%E6%AF%8F%E6%AC%A1%E7%BC%96%E8%AF%91%E6%88%91%E5%BA%94%E8%AF%A5%E4%BF%9D%E7%95%99%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9andresguard

dependencies {
    // 指定tinker依赖版本（注：应用升级1.3.5版本起，不再内置tinker）
    implementation 'com.tencent.tinker:tinker-android-lib:1.9.13'
}

apply plugin: 'com.tencent.bugly.tinker-support'

import java.util.regex.Matcher
import java.util.regex.Pattern

def bakPath = file("${project.projectDir}/bakApk")

project.ext.bakPath = bakPath


def flavorDir = ""
def flavorPrefix = ""
if (flavorName != ""){
    flavorDir = "/${flavorName}"
    flavorPrefix = "-${flavorName}"
}
//路径
def pathPrefix = "${bakPath}/${baseApkDir}${flavorDir}"
//文件名
def name = "${project.name}${flavorPrefix}-${variantName}"

/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {
    // 开启tinker-support插件，默认值true
    enable = isRelease()

    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性
    tinkerId = "$outTinkerId"

    // 指定归档目录，默认值为module下tinker目录
    autoBackupApkDir = "${bakPath}"

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = "${pathPrefix}/${name}.apk"

    // 对应tinker插件applyMapping
    baseApkProguardMapping = "${pathPrefix}/${name}-mapping.txt"

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = "${pathPrefix}/${name}-R.txt"

    // 构建多渠道补丁时使用
    buildAllFlavorsDir = "${bakPath}/${baseApkDir}"

    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）
    isProtectedApp = true

    // 是否开启反射Application模式
    enableProxyApplication = false

    // 是否启用覆盖tinkerPatch配置功能，默认值false
    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
    overrideTinkerPatchConfiguration = true
}

/**
 * 用于用户在代码中判断tinkerPatch是否被使能
 */
android {
    defaultConfig {
        buildConfigField "boolean", "TINKER_ENABLE", "${tinkerSupport.enable}"
    }
}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    //是否使用tinker编译，用于兼容开发时instant run模式
    tinkerEnable = isRelease()

    //oldApk ="${pathPrefix}/${name}-andresguard.apk"

    //在编译的patch可能有风险时，将中断编译。
    ignoreWarning = false

    //在运行过程中，我们需要验证基准apk包与补丁包的签名是否一致，我们是否需要为你签名。
    useSign = true

    dex {
        dexMode = "jar"
        pattern = ["classes*.dex"]
        loader = []
    }
    lib {
        pattern = ["lib/*/*.so"]
    }

    res {
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:${ANDRESGUARD_VERSION}"
        //path = "/usr/local/bin/7za"
    }
    buildConfig {
        keepDexApply = false
        // 在 overrideTinkerPatchConfiguration 为 false时， 需要使用下面这行定义 tinkerId
        tinkerId = "$outTinkerId"
        // 可选，设置mapping文件，建议保持旧apk的proguard混淆方式
        //applyMapping = "${pathPrefix}/${name}-mapping.txt"
        // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配
        //applyResourceMapping = "${pathPrefix}/${name}-R.txt"
    }
}


/**
 * 如果只想在Release中打开tinker，可以把tinkerEnable赋值为这个函数的return
 * @return 是否为release
 */
boolean isRelease() {
    String  tskReqStr = getGradle().getStartParameter().getTaskRequests().toString()

    Pattern pattern
    if (tskReqStr.contains("resguard")) {
        println tskReqStr
        pattern = Pattern.compile("resguard(\\w*)(Release|Debug)")
    } else if (tskReqStr.contains("assemble")) {
        println tskReqStr
        pattern = Pattern.compile("assemble(\\w*)(Release|Debug)")
    } else {
        pattern = Pattern.compile("generate(\\w*)(Release|Debug)")
    }
    Matcher matcher = pattern.matcher(tskReqStr)

    if (matcher.find()) {
        String task = matcher.group(0).toLowerCase()
        println("[BuildType] Current task: " + task)
        return task.contains("release")
    } else {
        println "[BuildType] NO MATCH FOUND"
        return true
    }
}

apply from: "resguard.gradle"

